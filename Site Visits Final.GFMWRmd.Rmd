---
title: "AT Random Walk1"
author: "Ferone and Woodstock"
date: "2024-06-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#setwd("/Users/garrisonferone/Desktop/RANWALK")
library(dplyr)
library(gratia)
library(mgcv)
library(ggplot2)
library(dplyr)
library(cowplot)
library(rticles)
library(lme4)
library(gam)
library(AICcmodavg)
library(MuMIn)
library(car)
library(visreg)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r probability walk, echo=TRUE}
is_within_red_circle <- function(x, y, diameter) {
  sqrt(x^2 + y^2) <= diameter / 2
}

# Function to generate points for a semi-circle
semi_circle_points <- function(center_x, center_y, diameter, num_points) {
  theta <- seq(-pi/2, pi/2, length.out = num_points)  # Generate theta between -pi/2 and pi/2 for semi-circle
  x <- center_x + diameter/2 * cos(theta)
  y <- center_y + diameter/2 * sin(theta)
  return(data.frame(x, y))
}

# Function to perform random walk with boundaries enforcement (Changes direction when approchaing boundary)
random_walk_with_boundaries <- function(num_steps, step_length, interval_duration, boundary_radius, initial_position) {
  positions <- matrix(nrow = num_steps + 1, ncol = 2)
  positions[1, ] <- initial_position
  
  for (i in 2:(num_steps + 1)) {
    # Swimming Velocity is now random with a maximum value of the assigned step length
    velo <- step_length * runif(1,0,1)
    # Generate a random direction
    direction <- runif(1, 0, 2 * pi)
    
    # Update position
    new_x <- positions[i - 1, 1] + velo * cos(direction)
    new_y <- positions[i - 1, 2] + velo * sin(direction)
    
    # Check if the new position exceeds the boundary, if so, adjust it
    distance_from_center <- sqrt(new_x^2 + new_y^2)
    if (distance_from_center > boundary_radius) {
      scale_factor <- boundary_radius / distance_from_center
      new_x <- new_x * scale_factor
      new_y <- new_y * scale_factor
    }
    
    # Check if the new position exceeds the x = 0 boundary, if so, adjust it
    if (new_x < 0) {
      new_x <- 0
    }
    
    positions[i, ] <- c(new_x, new_y)
  }
  
  return(data.frame(positions))
}

# Function to generate points along the path every N minutes
# Function to generate points along the path every N minutes with detection probabilities
generate_positions_every_N_minutes <- function(path_df, interval_duration, diameter, N) {
  positions <- list()
  for (i in 1:nrow(path_df)) {
    if ((i - 1) %% (interval_duration / N) == 0) {
      positions[[length(positions) + 1]] <- path_df[i, c("X1", "X2")]
    }
  }
  positions_df <- do.call(rbind, positions)
  
  # Add a time column starting from 0 seconds for 1-minute intervals
  if (N == 1) {
    positions_df$time <- seq(0, by = 60, length.out = nrow(positions_df))
  }
  
  # Function to generate presence/absence along the path every second
  generate_positions_every_second <- function(path_df, interval_duration, diameter) {
    positions <- list()
    for (i in 1:nrow(path_df)) {
      positions[[length(positions) + 1]] <- path_df[i, c("X1", "X2")]
    }
    positions_df <- do.call(rbind, positions)
    
    # Add a time column starting from 0 seconds for each second
    positions_df$time <- rep(0:(nrow(positions_df) - 1), each = interval_duration)
    
    # Calculate Presence based on the red semicircle
    positions_df$Presence <- sapply(1:nrow(positions_df), function(i) {
      is_within_red_circle(positions_df[i, "X1"], positions_df[i, "X2"], diameter)
    })
    
    return(positions_df)
  }
  
  # Prob of Detection based on the red, orange, and pink semicircle location
  positions_df$Detection <- sapply(1:nrow(positions_df), function(i) {
    x <- positions_df[i, "X1"]
    y <- positions_df[i, "X2"]
    distance_from_center <- sqrt(x^2 + y^2)
    if (distance_from_center <= diameter / 4) {
      return(TRUE)  # 100% chance of detection inside the pink scircle
    } else if (distance_from_center <= diameter * 0.75 / 2) {
      return(runif(1) <= 0.75)  # 75% chance of detection between the orange and pink scircles
    } else if (distance_from_center <= diameter / 2) {
      return(runif(1) <= 0.5)  # 50% chance of detection between the red and orange circles
    } else {
      return(FALSE)
    }
  })
  
  return(positions_df)
}


# Parameters
diameter <- 250  # Diameter of the circular receiver in meters
speed_blue <- 1  # Speed of the blue sharks in meters per second
simulation_duration <- 60*60*24  # Duration of simulation in seconds (1 day)
interval_duration <- 60*5  # Interval duration for detections in seconds (5 minutes)
boundary_radius <- 50000  # Radius of the boundary from the center of the largest circle
N <- 1  # Change to 1 minute interval

# Calculate number of steps
num_steps <- simulation_duration

# Step length (equal to the speed of the sharks)
step_length <- speed_blue

# Perform random walk with boundaries
blue_path <- random_walk_with_boundaries(num_steps, step_length, interval_duration, boundary_radius, initial_position = c(100, 0))

# Add time column
blue_path$time <- seq(0, by = 1, length.out = nrow(blue_path))

# Calculate detection based on the red semi-circle condition
blue_path$Detection <- sapply(1:nrow(blue_path), function(i) {
  is_within_red_circle(blue_path[i, "X1"], blue_path[i, "X2"], diameter)
})
# Generate positions every 5 minutes
positions_every_5_minutes <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, N)
positions_every_5_minutes$time <- seq(0, by = 300, length.out = nrow(positions_every_5_minutes))

# Generate positions every 1 minute
positions_every_1_minute <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, 5)
positions_every_1_minute$time <- seq(0, by = 60, length.out = nrow(positions_every_1_minute))


# Semi circle construction
semi_circle_points_large <- semi_circle_points(0, 0, diameter, num_points = 1000)
semi_circle_points_medium <- semi_circle_points(0, 0, diameter * 0.75, num_points = 1000)
semi_circle_points_small <- semi_circle_points(0, 0, diameter * 0.5, num_points = 1000)

# Plot the random walk
ggplot() +
  geom_path(data = blue_path, aes(x = X1, y = X2), color = "blue", linewidth = 0.05) +
  geom_point(data = positions_every_5_minutes, aes(x = X1, y = X2, color = Detection), size = 0.5) +
  geom_point(data = positions_every_1_minute, aes(x = X1, y = X2, color = Detection), size = 0.001, shape = 1, color = "black") + 
  geom_point(data = semi_circle_points_large, aes(x, y), color = "red", size = 0.3) +
  geom_point(data = semi_circle_points_medium, aes(x, y), color = "orange", size = 0.3) +
  geom_point(data = semi_circle_points_small, aes(x, y), color = "pink", size = 0.3) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +  #vertical boundary line
  coord_equal() +  # Equal aspect ratio-
  labs(x = "X (meters)", y = "Y (meters)", color = "Detection") +  # Axis labels
  ggtitle("Random Walk of 1 Shark in Semi-Circular Receiver") +  # Title
  theme_minimal()  # Minimal theme


count_visits <- function(detections, threshold) {
  visit_count <- 0
  gap_duration <- 0
  in_gap <- FALSE
  
  for (i in 1:length(detections)) {
    if (detections[i] == FALSE) {
      # In a gap
      gap_duration <- gap_duration + 1
      in_gap <- TRUE
    } else {
      if (in_gap && gap_duration >= threshold) {
        # Completed a valid gap
        visit_count <- visit_count + 1
      }
      # Reset gap duration and in_gap flag
      gap_duration <- 0
      in_gap <- FALSE
    }
  }
  
  # Check the last gap in the sequence
  if (in_gap && gap_duration >= threshold) {
    visit_count <- visit_count + 1
  }
  
  return(visit_count)
}

residency_1_sec <- sum(blue_path$Detection) / nrow(blue_path)
residency_1_min <- sum(positions_every_1_minute$Detection) / nrow(positions_every_1_minute)
residency_5_min <- sum(positions_every_5_minutes$Detection) / nrow(positions_every_5_minutes)
hourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 3600)
hourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 60)
hourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 12)
twohourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 7200)
twohourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 120)
twohourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 24)

halfhourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 1800)
halfhourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 30)
halfhourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 6)

# Create the result table
result_table <- data.frame(
  "1 Second Residency" = residency_1_sec,
  "1 Minute Residency" = residency_1_min,
  "5 Minute Residency" = residency_5_min,
  "1 Hour Visits (1 Second)" = hourvisit_count_1_sec,
  "1 Hour Visits (1 Minute)" = hourvisit_count_1_min,
  "1 Hour Visits (5 Minutes)" = hourvisit_count_5_min,
  "2 Hour Visits (1 Second)" = twohourvisit_count_1_sec,
  "2 Hour Visits (1 Minute)" = twohourvisit_count_1_min,
  "2 Hour Visits (5 Minutes)" = twohourvisit_count_5_min,
  "half Hour Visits (1 Second)" = halfhourvisit_count_1_sec,
  "half Hour Visits (1 Minute)" = halfhourvisit_count_1_min,
  "half Hour Visits (5 Minutes)" = halfhourvisit_count_5_min
)


ggplot(blue_path, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "Inside Receiver Range", color = "Detection") +
  ggtitle("1 sec Timeline Plot of Shark Path") +
  theme_minimal()

# Plot timeline for positions_every_1_minute
ggplot(positions_every_1_minute, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "Detection", color = "Detection") +
  ggtitle("Timeline Plot of Detection in positions_every_1_minute") +
  theme_minimal()

# Plot timeline for positions_every_5_minutes
ggplot(positions_every_5_minutes, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "Detection", color = "Detection") +
  ggtitle("Timeline Plot of Detection in positions_every_5_minutes") +
  theme_minimal()

print(result_table)


```


```{r probability walk, echo=TRUE}
library(dplyr)

# Calculate total number of True values for positions_every_5_minutes
total_true_5_minutes <- sum(positions_every_5_minutes$Detection)

# Plot timeline for positions_every_5_minutes
plot_5_minutes <- ggplot(positions_every_5_minutes, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "Detection", color = "Detection") +
  ggtitle("Timeline Plot of Detection in positions_every_5_minutes") +
  theme_minimal() +
  geom_text(x = 0, y = -Inf, label = paste("Total True:", total_true_5_minutes), hjust = 0, vjust = 0, color = "black")

# Calculate total number of True values for positions_every_1_minute
total_true_1_minute <- sum(positions_every_1_minute$Detection)

# Plot timeline for positions_every_1_minute
plot_1_minute <- ggplot(positions_every_1_minute, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "Detection", color = "Detection") +
  ggtitle("Timeline Plot of Detection in positions_every_1_minute") +
  theme_minimal() +
  geom_text(x = 0, y = -Inf, label = paste("Total True:", total_true_1_minute), hjust = 0, vjust = 0, color = "black")

total_true_1_second <- sum(blue_path$Detection)

plot_Actual <- ggplot(blue_path, aes(x = time, y = Detection, color = Detection)) +
  geom_point(size = 0.01) +
  labs(x = "Time", y = "inside the receiver", color = "Detection") +
  ggtitle("Timeline Plot of Actual Time in Seconds") +
  theme_minimal() +
  geom_text(x = 0, y = -Inf, label = paste("Total True:", total_true_1_second), hjust = 0, vjust = 0, color = "black")

# Combine the plots
library(gridExtra)
grid.arrange(plot_5_minutes, plot_1_minute, plot_Actual, ncol = 1)

```
```{r whatever}
write.csv(blue_path, file = "blue_path.csv", row.names = FALSE)
write.csv(blue_path, file = "positions_every_5_minutes.csv", row.names = FALSE)
write.csv(blue_path, file = "positions_every_1_minute.csv", row.names = FALSE)
getwd()
```

```{r trials}
# Required Libraries
library(ggplot2)

# Function Definitions
is_within_red_circle <- function(x, y, diameter) {
  sqrt(x^2 + y^2) <= diameter / 2
}

semi_circle_points <- function(center_x, center_y, diameter, num_points) {
  theta <- seq(-pi/2, pi/2, length.out = num_points)
  x <- center_x + diameter/2 * cos(theta)
  y <- center_y + diameter/2 * sin(theta)
  return(data.frame(x, y))
}

random_walk_with_boundaries <- function(num_steps, step_length, interval_duration, boundary_radius, initial_position) {
  positions <- matrix(nrow = num_steps + 1, ncol = 2)
  positions[1, ] <- initial_position
  
  for (i in 2:(num_steps + 1)) {
    velo <- step_length * runif(1, 0, 1)
    direction <- runif(1, 0, 2 * pi)
    
    new_x <- positions[i - 1, 1] + velo * cos(direction)
    new_y <- positions[i - 1, 2] + velo * sin(direction)
    
    distance_from_center <- sqrt(new_x^2 + new_y^2)
    if (distance_from_center > boundary_radius) {
      scale_factor <- boundary_radius / distance_from_center
      new_x <- new_x * scale_factor
      new_y <- new_y * scale_factor
    }
    
    if (new_x < 0) {
      new_x <- 0
    }
    
    positions[i, ] <- c(new_x, new_y)
  }
  
  return(data.frame(positions))
}

generate_positions_every_N_minutes <- function(path_df, interval_duration, diameter, N) {
  positions <- list()
  for (i in 1:nrow(path_df)) {
    if ((i - 1) %% (interval_duration / N) == 0) {
      positions[[length(positions) + 1]] <- path_df[i, c("X1", "X2")]
    }
  }
  positions_df <- do.call(rbind, positions)
  
  if (N == 1) {
    positions_df$time <- seq(0, by = 60, length.out = nrow(positions_df))
  }
  
  positions_df$Detection <- sapply(1:nrow(positions_df), function(i) {
    x <- positions_df[i, "X1"]
    y <- positions_df[i, "X2"]
    distance_from_center <- sqrt(x^2 + y^2)
    if (distance_from_center <= diameter / 4) {
      return(TRUE)
    } else if (distance_from_center <= diameter * 0.75 / 2) {
      return(runif(1) <= 0.75)
    } else if (distance_from_center <= diameter / 2) {
      return(runif(1) <= 0.5)
    } else {
      return(FALSE)
    }
  })
  
  return(positions_df)
}

count_visits <- function(detections, threshold) {
  visit_count <- 0
  gap_duration <- 0
  in_gap <- FALSE
  
  for (i in 1:length(detections)) {
    if (detections[i] == FALSE) {
      gap_duration <- gap_duration + 1
      in_gap <- TRUE
    } else {
      if (in_gap && gap_duration >= threshold) {
        visit_count <- visit_count + 1
      }
      gap_duration <- 0
      in_gap <- FALSE
    }
  }
  
  if (in_gap && gap_duration >= threshold) {
    visit_count <- visit_count + 1
  }
  
  return(visit_count)
}

# Parameters
diameter <- 250
speed_blue <- 1
simulation_duration <- 60 * 60 * 24
interval_duration <- 60 * 5
boundary_radius <- 50000
N <- 1
num_steps <- simulation_duration
step_length <- speed_blue

# Initialize results table
results <- data.frame()

# Run the simulation 50 times
for (sim in 1:50) {
  blue_path <- random_walk_with_boundaries(num_steps, step_length, interval_duration, boundary_radius, initial_position = c(100, 0))
  blue_path$time <- seq(0, by = 1, length.out = nrow(blue_path))
  blue_path$Detection <- sapply(1:nrow(blue_path), function(i) {
    is_within_red_circle(blue_path[i, "X1"], blue_path[i, "X2"], diameter)
  })
  
  positions_every_5_minutes <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, N)
  positions_every_5_minutes$time <- seq(0, by = 300, length.out = nrow(positions_every_5_minutes))
  positions_every_1_minute <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, 5)
  positions_every_1_minute$time <- seq(0, by = 60, length.out = nrow(positions_every_1_minute))
  
  residency_1_sec <- sum(blue_path$Detection) / nrow(blue_path)
  residency_1_min <- sum(positions_every_1_minute$Detection) / nrow(positions_every_1_minute)
  residency_5_min <- sum(positions_every_5_minutes$Detection) / nrow(positions_every_5_minutes)
  hourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 3600)
  hourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 60)
  hourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 12)
  twohourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 7200)
  twohourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 120)
  twohourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 24)
  halfhourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 1800)
  halfhourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 30)
  halfhourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 6)
  
  result_table <- data.frame(
    "1 Second Residency" = residency_1_sec,
    "1 Minute Residency" = residency_1_min,
    "5 Minute Residency" = residency_5_min,
    "1 Hour Visits (1 Second)" = hourvisit_count_1_sec,
    "1 Hour Visits (1 Minute)" = hourvisit_count_1_min,
    "1 Hour Visits (5 Minutes)" = hourvisit_count_5_min,
    "2 Hour Visits (1 Second)" = twohourvisit_count_1_sec,
    "2 Hour Visits (1 Minute)" = twohourvisit_count_1_min,
    "2 Hour Visits (5 Minutes)" = twohourvisit_count_5_min,
    "Half Hour Visits (1 Second)" = halfhourvisit_count_1_sec,
    "Half Hour Visits (1 Minute)" = halfhourvisit_count_1_min,
    "Half Hour Visits (5 Minutes)" = halfhourvisit_count_5_min
  )
  
  results <- rbind(results, result_table)
}

# Save results to CSV file
write.csv(results, file = "blue_path_simulation_results.csv", row.names = FALSE)

```



```{r trialsss 2}
# Required Libraries
library(ggplot2)

# Function Definitions
is_within_red_circle <- function(x, y, diameter) {
  sqrt(x^2 + y^2) <= diameter / 2
}

semi_circle_points <- function(center_x, center_y, diameter, num_points) {
  theta <- seq(-pi/2, pi/2, length.out = num_points)
  x <- center_x + diameter/2 * cos(theta)
  y <- center_y + diameter/2 * sin(theta)
  return(data.frame(x, y))
}

random_walk_with_boundaries <- function(num_steps, step_length, interval_duration, boundary_radius, initial_position) {
  positions <- matrix(nrow = num_steps + 1, ncol = 2)
  positions[1, ] <- initial_position
  
  for (i in 2:(num_steps + 1)) {
    velo <- step_length * runif(1, 0, 1)
    direction <- runif(1, 0, 2 * pi)
    
    new_x <- positions[i - 1, 1] + velo * cos(direction)
    new_y <- positions[i - 1, 2] + velo * sin(direction)
    
    distance_from_center <- sqrt(new_x^2 + new_y^2)
    if (distance_from_center > boundary_radius) {
      scale_factor <- boundary_radius / distance_from_center
      new_x <- new_x * scale_factor
      new_y <- new_y * scale_factor
    }
    
    if (new_x < 0) {
      new_x <- 0
    }
    
    positions[i, ] <- c(new_x, new_y)
  }
  
  return(data.frame(positions))
}

generate_positions_every_N_minutes <- function(path_df, interval_duration, diameter, N) {
  positions <- list()
  for (i in 1:nrow(path_df)) {
    if ((i - 1) %% (interval_duration / N) == 0) {
      positions[[length(positions) + 1]] <- path_df[i, c("X1", "X2")]
    }
  }
  positions_df <- do.call(rbind, positions)
  
  if (N == 1) {
    positions_df$time <- seq(0, by = 60, length.out = nrow(positions_df))
  }
  
  positions_df$Detection <- sapply(1:nrow(positions_df), function(i) {
    x <- positions_df[i, "X1"]
    y <- positions_df[i, "X2"]
    distance_from_center <- sqrt(x^2 + y^2)
    if (distance_from_center <= diameter / 4) {
      return(TRUE)
    } else if (distance_from_center <= diameter * 0.75 / 2) {
      return(runif(1) <= 0.75)
    } else if (distance_from_center <= diameter / 2) {
      return(runif(1) <= 0.5)
    } else {
      return(FALSE)
    }
  })
  
  return(positions_df)
}

count_visits <- function(detections, threshold) {
  visit_count <- 0
  gap_duration <- 0
  in_gap <- FALSE
  
  for (i in 1:length(detections)) {
    if (detections[i] == FALSE) {
      gap_duration <- gap_duration + 1
      in_gap <- TRUE
    } else {
      if (in_gap && gap_duration >= threshold) {
        visit_count <- visit_count + 1
      }
      gap_duration <- 0
      in_gap <- FALSE
    }
  }
  
  if (in_gap && gap_duration >= threshold) {
    visit_count <- visit_count + 1
  }
  
  return(visit_count)
}

# Parameters
diameter <- 250
speed_blue <- 1
simulation_duration <- 60 * 60 * 24
interval_duration <- 60 * 5
boundary_radius <- 50000
N <- 1
num_steps <- simulation_duration
step_length <- speed_blue

# Initialize results storage
results <- data.frame()

# Run the simulation 50 times
for (sim in 1:5) {
  blue_path <- random_walk_with_boundaries(num_steps, step_length, interval_duration, boundary_radius, initial_position = c(100, 0))
  blue_path$time <- seq(0, by = 1, length.out = nrow(blue_path))
  blue_path$Detection <- sapply(1:nrow(blue_path), function(i) {
    is_within_red_circle(blue_path[i, "X1"], blue_path[i, "X2"], diameter)
  })
  
  positions_every_5_minutes <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, N)
  positions_every_5_minutes$time <- seq(0, by = 300, length.out = nrow(positions_every_5_minutes))
  positions_every_1_minute <- generate_positions_every_N_minutes(blue_path, interval_duration, diameter, 5)
  positions_every_1_minute$time <- seq(0, by = 60, length.out = nrow(positions_every_1_minute))
  
  residency_1_sec <- sum(blue_path$Detection) / nrow(blue_path)
  residency_1_min <- sum(positions_every_1_minute$Detection) / nrow(positions_every_1_minute)
  residency_5_min <- sum(positions_every_5_minutes$Detection) / nrow(positions_every_5_minutes)
  hourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 3600)
  hourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 60)
  hourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 12)
  twohourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 7200)
  twohourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 120)
  twohourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 24)
  halfhourvisit_count_1_sec <- count_visits(blue_path$Detection, threshold = 1800)
  halfhourvisit_count_1_min <- count_visits(positions_every_1_minute$Detection, threshold = 30)
  halfhourvisit_count_5_min <- count_visits(positions_every_5_minutes$Detection, threshold = 6)
  
  result_table <- data.frame(
    "1 Second Residency" = residency_1_sec,
    "1 Minute Residency" = residency_1_min,
    "5 Minute Residency" = residency_5_min,
    "1 Hour Visits (1 Second)" = hourvisit_count_1_sec,
    "1 Hour Visits (1 Minute)" = hourvisit_count_1_min,
    "1 Hour Visits (5 Minutes)" = hourvisit_count_5_min,
    "2 Hour Visits (1 Second)" = twohourvisit_count_1_sec,
    "2 Hour Visits (1 Minute)" = twohourvisit_count_1_min,
    "2 Hour Visits (5 Minutes)" = twohourvisit_count_5_min,
    "Half Hour Visits (1 Second)" = halfhourvisit_count_1_sec,
    "Half Hour Visits (1 Minute)" = halfhourvisit_count_1_min,
    "Half Hour Visits (5 Minutes)" = halfhourvisit_count_5_min
  )
  
  results <- rbind(results, result_table)
}

# Calculate averages
average_results <- data.frame(
  "1 Second Residency" = mean(results$`1.Second.Residency`),
  "1 Minute Residency" = mean(results$`1.Minute.Residency`),
  "5 Minute Residency" = mean(results$`5.Minute.Residency`),
  "1 Hour Visits (1 Second)" = mean(results$`1.Hour.Visits..1.Second..`),
  "1 Hour Visits (1 Minute)" = mean(results$`1.Hour.Visits..1.Minute..`),
  "1 Hour Visits (5 Minutes)" = mean(results$`1.Hour.Visits..5.Minutes..`),
  "2 Hour Visits (1 Second)" = mean(results$`2.Hour.Visits..1.Second..`),
  "2 Hour Visits (1 Minute)" = mean(results$`2.Hour.Visits..1.Minute..`),
  "2 Hour Visits (5 Minutes)" = mean(results$`2.Hour.Visits..5.Minutes..`),
  "Half Hour Visits (1 Second)" = mean(results$`Half.Hour.Visits..1.Second..`),
  "Half Hour Visits (1 Minute)" = mean(results$`Half.Hour.Visits..1.Minute..`),
  "Half Hour Visits (5 Minutes)" = mean(results$`Half.Hour.Visits..5.Minutes..`)
)

# Save results to CSV file
write.csv(average_results, file = "average_blue_path_simulation_results.csv", row.names = FALSE)

# Print the average results
print(average_results)


```



